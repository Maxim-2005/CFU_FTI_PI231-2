from random import randint
from numpy.linalg import solve as gauss
import numpy as np
from math import exp
from dsmltf import scale, mult_r_squared, mult_predict, dot

# Генерация данных для решения задачи: стоит ли идти на пару
# Характеристики: 
# 1 - практика (1) или лекция (0)
# 2 - профильный предмет (1) или нет (0)
# 3 - обязательны конспекты (1) или нет (0)
# 4 - хочется кушать (1) или нет (0)
# 5 - это третья пара и более (1) или нет (0)
# 6 - есть еще пары после этой (1) или нет (0)
# 7 - сложность предмета от 1 до 5
# Результат: решение, пойдет ли студент на пару (1 - да, 0 - нет)

def make_data() -> list:
    data = []
    for i in range(30):
        # Генерация случайных данных для каждого признака
        arr = [randint(0,1), randint(0,1), randint(0,1), randint(0,1), randint(0,1), randint(0,1), randint(1,5)]
        
        # Вывод информации по каждому признаку
        print("Практика" * arr[0] + "Лекция" * (not arr[0]))
        print("Предмет -", "профильный" * arr[1] + "не профильный" * (not arr[1]))
        print("Конспекты -", "обязательны" * arr[2] + "не обязательны" * (not arr[2]))
        print("Кушать", "хочется" * arr[3] + "не хочется" * (not arr[3]))
        print("Пара уже 3+", "Да" * arr[4] + "Нет" * (not arr[4]))
        print("Есть ли еще пары?", "Да" * arr[5] + "Нет" * (not arr[5]))
        print(f"Предмет сложен на {arr[6]}")
        
        # Запрашиваем у пользователя, пойдет ли он на пару
        arr.append(int(input("Пойдешь ли на пару? ")))
        data.append(arr)
    return data

# Функция для решения линейной регрессии методом Гаусса
def regression(X, y):  # X – это список векторов
    n = len(y)
    M = []
    b = []
    
    # Формируем матрицу системы уравнений
    M.append([sum(x) for x in X] + [n])
    b.append(sum(y))
    for _, xl in enumerate(X):
        M.append([dot(x, xl) for x in X] + [sum(xl)])
        b.append(dot(y, xl))
    
    # Решаем систему методом Гаусса
    beta = gauss(np.array(M, dtype="float64"), np.array(b, dtype="float64"))
    return beta  # свободный коэффициент находится в конце beta[-1]

def main():
    # Предварительно собранные данные
    data = [[1, 1, 0, 1, 0, 0, 3, 1], [1, 0, 1, 1, 1, 0, 5, 1], [1, 1, 1, 0, 0, 0, 3, 1], 
            [1, 1, 0, 1, 1, 0, 4, 1], [1, 1, 1, 0, 1, 0, 4, 1], [0, 0, 0, 0, 0, 0, 1, 0], 
            [0, 1, 0, 1, 0, 1, 5, 1], [0, 1, 0, 0, 0, 0, 3, 0], [1, 0, 0, 0, 1, 0, 2, 0], 
            [0, 1, 0, 0, 1, 1, 3, 1], [1, 0, 1, 1, 1, 1, 4, 1], [0, 1, 0, 1, 0, 0, 5, 0], 
            [1, 1, 1, 1, 1, 0, 1, 0], [0, 0, 0, 1, 0, 0, 2, 0], [0, 1, 0, 1, 1, 0, 2, 0], 
            [1, 1, 0, 1, 0, 1, 1, 1], [0, 0, 0, 1, 0, 1, 5, 1], [1, 0, 0, 0, 1, 1, 3, 1], 
            [1, 0, 1, 0, 0, 0, 4, 1], [0, 1, 1, 1, 1, 0, 1, 0], [0, 0, 0, 0, 1, 0, 5, 0], 
            [0, 1, 1, 0, 1, 1, 4, 1], [1, 1, 1, 1, 1, 1, 5, 1], [0, 1, 0, 0, 0, 1, 1, 0], 
            [0, 1, 1, 1, 1, 1, 5, 1], [0, 1, 0, 1, 0, 1, 3, 1], [0, 1, 1, 0, 0, 1, 4, 1], 
            [0, 0, 1, 0, 0, 0, 1, 0], [1, 0, 1, 1, 0, 1, 3, 1], [0, 0, 0, 0, 0, 0, 5, 0]]
    
    # Инициализация матриц для обучения
    X = [[], [], [], [], [], [], []]
    y = []
    
    # Масштабируем данные
    dat = scale(data)
    
    # Переводим данные в нужный формат для регрессии
    for i in range(len(dat[:-10])):
        for j in range(7):
            X[j].append(dat[i][j])
        y.append(dat[i][-1])
    
    # Выполняем линейную регрессию для нахождения коэффициентов
    beta = regression(X, y)
    
    # Вычисляем метрику ошибки по квадратам
    R = mult_r_squared([i[:-1] for i in dat[-10:]], y, beta)
    
    # Тестируем на отложенной выборке
    for i in range(20, 30):
        Y = mult_predict(dat[i][:-1], beta)
        answer = round(exp(Y) / (1 + exp(Y)))  # Логистическая функция для предсказания
        if data[i][-1] != answer:
            print(f"Ошибка предсказания, должно быть {data[i][-1]}, а получилось {answer}, data:{data[i]}")
    
    print(f"Ошибка по квадратам: {R}")

# Запуск основной программы
if __name__ == "__main__":
    main()
